//
//  UIColor+Extension.m
//  AFNetworking
//
//  Created by meb on 2019/4/25.
//**********************************
//     ______    _______          **
//    /\  __ \  /\   ___\         **
//    \ \  __C  \ \  \___         **
//     \ \_____\ \ \_____\        **
//      \/_____/  \ \             **
//                 \F\            **
//**********************************

#import "UIColor+Extension.h"

@implementation UIColor (Extension)

#pragma mark - WonderfulColor(各种漂亮颜色)
#pragma mark 红色系
/** 薄雾玫瑰*/
+ (UIColor *)mistyRose
{
    return CFRGB16Color(0xFFE4E1);
}
/** 浅鲑鱼色*/
+ (UIColor *)lightSalmon
{
    return CFRGB16Color(0xFFA07A);
}
/** 淡珊瑚色*/
+ (UIColor *)lightCoral
{
    return CFRGB16Color(0xF08080);
}
/** 鲑鱼色*/
+ (UIColor *)salmonColor
{
    return CFRGB16Color(0xFA8072);
}
/** 珊瑚色*/
+ (UIColor *)coralColor
{
    return CFRGB16Color(0xFF7F50);
}
/** 番茄*/
+ (UIColor *)tomatoColor
{
    return CFRGB16Color(0xFF6347);
}
/** 橙红色*/
+ (UIColor *)orangeRed
{
    return CFRGB16Color(0xFF4500);
}
/** 印度红*/
+ (UIColor *)indianRed
{
    return CFRGB16Color(0xCD5C5C);
}
/** 猩红*/
+ (UIColor *)crimsonColor
{
    return CFRGB16Color(0xDC143C);
}
/** 耐火砖*/
+ (UIColor *)fireBrick
{
    return CFRGB16Color(0xB22222);
}


#pragma mark 黄色系
/** 玉米色*/
+ (UIColor *)cornColor
{
    return CFRGB16Color(0xFFF8DC);
}
/** 柠檬薄纱*/
+ (UIColor *)LemonChiffon
{
    return CFRGB16Color(0xFFFACD);
}
/** 苍金麒麟*/
+ (UIColor *)paleGodenrod
{
    return CFRGB16Color(0xEEE8AA);
}
/** 卡其色*/
+ (UIColor *)khakiColor
{
    return CFRGB16Color(0xF0E68C);
}
/** 金色*/
+ (UIColor *)goldColor
{
    return CFRGB16Color(0xFFD700);
}
/** 雌黄*/
+ (UIColor *)orpimentColor
{
    return CFRGB16Color(0xFFC64B);
}
/** 藤黄*/
+ (UIColor *)gambogeColor
{
    return CFRGB16Color(0xFFB61E);
}
/** 雄黄*/
+ (UIColor *)realgarColor
{
    return CFRGB16Color(0xE9BB1D);
}
/** 金麒麟色*/
+ (UIColor *)goldenrod
{
    return CFRGB16Color(0xDAA520);
}
/** 乌金*/
+ (UIColor *)darkGold
{
    return CFRGB16Color(0xA78E44);
}


#pragma mark 绿色系
/** 苍绿*/
+ (UIColor *)paleGreen
{
    return CFRGB16Color(0x98FB98);
}
/** 淡绿色*/
+ (UIColor *)lightGreen
{
    return CFRGB16Color(0x90EE90);
}
/** 春绿*/
+ (UIColor *)springGreen
{
    return CFRGB16Color(0x2AFD84);
}
/** 绿黄色*/
+ (UIColor *)greenYellow
{
    return CFRGB16Color(0xADFF2F);
}
/** 草坪绿*/
+ (UIColor *)lawnGreen
{
    return CFRGB16Color(0x7CFC00);
}
/** 酸橙绿*/
+ (UIColor *)limeColor
{
    return CFRGB16Color(0x00FF00);
}
/** 森林绿*/
+ (UIColor *)forestGreen
{
    return CFRGB16Color(0x228B22);
}
/** 海洋绿*/
+ (UIColor *)seaGreen
{
    return CFRGB16Color(0x2E8B57);
}
/** 深绿*/
+ (UIColor *)darkGreen
{
    return CFRGB16Color(0x006400);
}
/** 橄榄(墨绿)*/
+ (UIColor *)olive
{
    return CFRGB16Color(0x556B2F);
}


#pragma mark 青色系
/** 淡青色*/
+ (UIColor *)lightCyan
{
    return CFRGB16Color(0xE1FFFF);
}
/** 苍白绿松石*/
+ (UIColor *)paleTurquoise
{
    return CFRGB16Color(0xAFEEEE);
}
/** 绿碧*/
+ (UIColor *)aquamarine
{
    return CFRGB16Color(0x7FFFD4);
}
/** 绿松石*/
+ (UIColor *)turquoise
{
    return CFRGB16Color(0x40E0D0);
}
/** 适中绿松石*/
+ (UIColor *)mediumTurquoise
{
    return CFRGB16Color(0x48D1CC);
}
/** 美团色*/
+ (UIColor *)meituanColor
{
    return CFRGB16Color(0x2BB8AA);
}
/** 浅海洋绿*/
+ (UIColor *)lightSeaGreen
{
    return CFRGB16Color(0x20B2AA);
}
/** 深青色*/
+ (UIColor *)darkCyan
{
    return CFRGB16Color(0x008B8B);
}
/** 水鸭色*/
+ (UIColor *)tealColor
{
    return CFRGB16Color(0x008080);
}
/** 深石板灰*/
+ (UIColor *)darkSlateGray
{
    return CFRGB16Color(0x2F4F4F);
}


#pragma mark 蓝色系
/** 天蓝色*/
+ (UIColor *)skyBlue
{
    return CFRGB16Color(0xE1FFFF);
}
/** 淡蓝*/
+ (UIColor *)lightBLue
{
    return CFRGB16Color(0xADD8E6);
}
/** 深天蓝*/
+ (UIColor *)deepSkyBlue
{
    return CFRGB16Color(0x00BFFF);
}
/** 道奇蓝*/
+ (UIColor *)doderBlue
{
    return CFRGB16Color(0x1E90FF);
}
/** 矢车菊*/
+ (UIColor *)cornflowerBlue
{
    return CFRGB16Color(0x6495ED);
}
/** 皇家蓝*/
+ (UIColor *)royalBlue
{
    return CFRGB16Color(0x4169E1);
}
/** 适中的蓝色*/
+ (UIColor *)mediumBlue
{
    return CFRGB16Color(0x0000CD);
}
/** 深蓝*/
+ (UIColor *)darkBlue
{
    return CFRGB16Color(0x00008B);
}
/** 海军蓝*/
+ (UIColor *)navyColor
{
    return CFRGB16Color(0x000080);
}
/** 午夜蓝*/
+ (UIColor *)midnightBlue
{
    return CFRGB16Color(0x191970);
}


#pragma mark 紫色系
/** 薰衣草*/
+ (UIColor *)lavender
{
    return CFRGB16Color(0xE6E6FA);
}
/** 蓟*/
+ (UIColor *)thistleColor
{
    return CFRGB16Color(0xD8BFD8);
}
/** 李子*/
+ (UIColor *)plumColor
{
    return CFRGB16Color(0xDDA0DD);
}
/** 紫罗兰*/
+ (UIColor *)violetColor
{
    return CFRGB16Color(0xEE82EE);
}
/** 适中的兰花紫*/
+ (UIColor *)mediumOrchid
{
    return CFRGB16Color(0xBA55D3);
}
/** 深兰花紫*/
+ (UIColor *)darkOrchid
{
    return CFRGB16Color(0x9932CC);
}
/** 深紫罗兰色*/
+ (UIColor *)darkVoilet
{
    return CFRGB16Color(0x9400D3);
}
/** 泛蓝紫罗兰*/
+ (UIColor *)blueViolet
{
    return CFRGB16Color(0x8A2BE2);
}
/** 深洋红色*/
+ (UIColor *)darkMagenta
{
    return CFRGB16Color(0x8B008B);
}
/** 靛青*/
+ (UIColor *)indigoColor
{
    return CFRGB16Color(0x4B0082);
}


#pragma mark 灰色系
/** 白烟*/
+ (UIColor *)whiteSmoke
{
    return CFRGB16Color(0xF5F5F5);
}
/** 鸭蛋*/
+ (UIColor *)duckEgg
{
    return CFRGB16Color(0xE0EEE8);
}
/** 亮灰*/
+ (UIColor *)gainsboroColor
{
    return CFRGB16Color(0xDCDCDC);
}
/** 蟹壳青*/
+ (UIColor *)carapaceColor
{
    return CFRGB16Color(0xBBCDC5);
}
/** 银白色*/
+ (UIColor *)silverColor
{
    return CFRGB16Color(0xC0C0C0);
}
/** 暗淡的灰色*/
+ (UIColor *)dimGray
{
    return CFRGB16Color(0x696969);
}


#pragma mark 白色系
/** 海贝壳*/
+ (UIColor *)seaShell
{
    return CFRGB16Color(0xFFF5EE);
}
/** 雪*/
+ (UIColor *)snowColor
{
    return CFRGB16Color(0xFFFAFA);
}
/** 亚麻色*/
+ (UIColor *)linenColor
{
    return CFRGB16Color(0xFAF0E6);
}
/** 花之白*/
+ (UIColor *)floralWhite
{
    return CFRGB16Color(0xFFFAF0);
}
/** 老饰带*/
+ (UIColor *)oldLace
{
    return CFRGB16Color(0xFDF5E6);
}
/** 象牙白*/
+ (UIColor *)ivoryColor
{
    return CFRGB16Color(0xFFFFF0);
}
/** 蜂蜜露*/
+ (UIColor *)honeydew
{
    return CFRGB16Color(0xF0FFF0);
}
/** 薄荷奶油*/
+ (UIColor *)mintCream
{
    return CFRGB16Color(0xF5FFFA);
}
/** 蔚蓝色*/
+ (UIColor *)azureColor
{
    return CFRGB16Color(0xF0FFFF);
}
/** 爱丽丝蓝*/
+ (UIColor *)aliceBlue
{
    return CFRGB16Color(0xF0F8FF);
}
/** 幽灵白*/
+ (UIColor *)ghostWhite
{
    return CFRGB16Color(0xF8F8FF);
}
/** 淡紫红*/
+ (UIColor *)lavenderBlush
{
    return CFRGB16Color(0xFFF0F5);
}
/** 米色*/
+ (UIColor *)beigeColor
{
    return CFRGB16Color(0xF5F5DD);
}


#pragma mark 棕色系
/** 黄褐色*/
+ (UIColor *)tanColor
{
    return CFRGB16Color(0xD2B48C);
}
/** 玫瑰棕色*/
+ (UIColor *)rosyBrown
{
    return CFRGB16Color(0xBC8F8F);
}
/** 秘鲁*/
+ (UIColor *)peruColor
{
    return CFRGB16Color(0xCD853F);
}
/** 巧克力*/
+ (UIColor *)chocolateColor
{
    return CFRGB16Color(0xD2691E);
}
/** 古铜色*/
+ (UIColor *)bronzeColor
{
    return CFRGB16Color(0xB87333);
}
/** 黄土赭色*/
+ (UIColor *)siennaColor
{
    return CFRGB16Color(0xA0522D);
}
/** 马鞍棕色*/
+ (UIColor *)saddleBrown
{
    return CFRGB16Color(0x8B4513);
}
/** 土棕*/
+ (UIColor *)soilColor
{
    return CFRGB16Color(0x734A12);
}
/** 栗色*/
+ (UIColor *)maroonColor
{
    return CFRGB16Color(0x800000);
}
/** 乌贼墨棕*/
+ (UIColor *)inkfishBrown
{
    return CFRGB16Color(0x5E2612);
}


#pragma mark 粉色系
/** 水粉*/
+ (UIColor *)waterPink // $$$$$
{
    return CFRGB16Color(0xF3D3E7);
}
/** 藕色*/
+ (UIColor *)lotusRoot // $$$$$
{
    return CFRGB16Color(0xEDD1D8);
}
/** 浅粉红*/
+ (UIColor *)lightPink
{
    return CFRGB16Color(0xFFB6C1);
}
/** 适中的粉红*/
+ (UIColor *)mediumPink
{
    return CFRGB16Color(0xFFC0CB);
}
/** 桃红*/
+ (UIColor *)peachRed // $$$$$
{
    return CFRGB16Color(0xF47983);
}
/** 苍白的紫罗兰红色*/
+ (UIColor *)paleVioletRed
{
    return CFRGB16Color(0xDB7093);
}
/** 深粉色*/
+ (UIColor *)deepPink
{
    return CFRGB16Color(0xFF1493);
}


#pragma mark - AdjustColor(调色功能)
/**
 *  当前颜色向上添加指定的数
 *
 *  @param type 需要调整颜色的方向
 *  @param num  给定需要上调的数
 *
 *  @return 返回调整后的颜色
 */
- (UIColor *)up:(CFColorType)type num:(NSInteger)num{
    float r = [self red] * 255.0;
    float g = [self green] * 255.0;
    float b = [self blue] * 255.0;
    float a = [self alpha];
    
    switch (type) {
        case 1:
            return CFRGBAColor(r+num, g, b, a);
            break;
        case 2:
            return CFRGBAColor(r, g+num, b, a);
            break;
        case 3:
            return CFRGBAColor(r, g, b+num, a);
            break;
        case 4:
            return CFRGBAColor(r, g, b, a+num/255.0);
            break;
        default:
            return self;
            break;
    }
}

/**
 *  当前颜色向下减少指定的数
 *
 *  @param type 需要调整颜色的方向
 *  @param num  给定需要下调的数
 *
 *  @return 返回调整后的颜色
 */
- (UIColor *)down:(CFColorType)type num:(NSInteger)num{
    float r = [self red] * 255.0;
    float g = [self green] * 255.0;
    float b = [self blue] * 255.0;
    float a = [self alpha];
    
    switch (type) {
        case 1:
            return CFRGBAColor(r-num, g, b, a);
            break;
        case 2:
            return CFRGBAColor(r, g-num, b, a);
            break;
        case 3:
            return CFRGBAColor(r, g, b-num, a);
            break;
        case 4:
            return CFRGBAColor(r, g, b, a-num/255.0);
            break;
        default:
            return self;
            break;
    }
}



/**
 *  调整颜色亮度
 *
 *  @param amount 亮度值
 *
 *  @return 返回调整后的颜色
 */
- (UIColor *)adjustBrightness:(CGFloat)amount{
    CGFloat h, s, b, a, w;
    
    if ([self getHue:&h saturation:&s brightness:&b alpha:&a]) {
        b += (amount-1.0);
        b = MAX(MIN(b, 1.0), 0.0);
        return [UIColor colorWithHue:h saturation:s brightness:b alpha:a];
    }else if ([self getWhite:&w alpha:&a]) {
        w += (amount-1.0);
        w = MAX(MIN(w, 1.0), 0.0);
        return [UIColor colorWithWhite:w alpha:a];
    }
    return nil;
}



#pragma mark - SeparateColor(分离颜色功能)
/**
 *  判断当前颜色的空间模式
 *
 *  @return 返回当前颜色的空间模式
 */
- (CGColorSpaceModel)colorSpaceModel{
    return CGColorSpaceGetModel(CGColorGetColorSpace(self.CGColor));
}


/**
 *  根据颜色空间模式返回对应的颜色模式的字符串
 *
 *  @return 返回当前颜色的颜色模式的字符串
 */
- (NSString *)colorSpaceString{
    switch ([self colorSpaceModel])
    {
        case kCGColorSpaceModelUnknown:
            return @"kCGColorSpaceModelUnknown";
        case kCGColorSpaceModelMonochrome:
            return @"kCGColorSpaceModelMonochrome";
        case kCGColorSpaceModelRGB:
            return @"kCGColorSpaceModelRGB";
        case kCGColorSpaceModelCMYK:
            return @"kCGColorSpaceModelCMYK";
        case kCGColorSpaceModelLab:
            return @"kCGColorSpaceModelLab";
        case kCGColorSpaceModelDeviceN:
            return @"kCGColorSpaceModelDeviceN";
        case kCGColorSpaceModelIndexed:
            return @"kCGColorSpaceModelIndexed";
        case kCGColorSpaceModelPattern:
            return @"kCGColorSpaceModelPattern";
        default:
            return @"Not a valid color space";
    }
}

/**
 *  返回当前颜色的颜色空间中的红色相关的数字
 *
 *  @return 返回当前颜色控件中红色的值
 */
- (CGFloat)red{
    const CGFloat *c = CGColorGetComponents(self.CGColor);
    return c[0];
}


/**
 *  返回当前颜色的颜色空间中的绿色相关的数字
 *
 *  @return 返回当前颜色控件中绿色的值
 */
- (CGFloat)green{
    const CGFloat *c = CGColorGetComponents(self.CGColor);
    if ([self colorSpaceModel] == kCGColorSpaceModelMonochrome) return c[0];
    return c[1];
}


/**
 *  返回当前颜色的颜色空间中的蓝色相关的数字
 *
 *  @return 返回当前颜色控件中蓝色的值
 */
- (CGFloat)blue{
    const CGFloat *c = CGColorGetComponents(self.CGColor);
    if ([self colorSpaceModel] == kCGColorSpaceModelMonochrome) return c[0];
    return c[2];
}


/**
 *  返回当前颜色的颜色空间中的透明度相关的数字
 *
 *  @return 返回当前颜色控件中透明度的值
 */
- (CGFloat)alpha{
    const CGFloat *c = CGColorGetComponents(self.CGColor);
    return c[CGColorGetNumberOfComponents(self.CGColor)-1];
}


/**
 *  翻转当前颜色，也就是反色
 *
 *  @return 返回当前颜色的反色
 */
- (UIColor *)reverseColor{
    float r= 1 - [self red];
    float g= 1 - [self green];
    float b= 1 - [self blue];
    float alpha= [self alpha];
    UIColor *rcolor = [UIColor colorWithRed:r green:g blue:b alpha:alpha];
    return rcolor;
}


/**
 *  打印当前颜色的信息值
 */
- (void)printDetail{
    float r= [self red];
    float g= [self green];
    float b= [self blue];
    float R= [self red] * 255;
    float G= [self green] *255;
    float B= [self blue] *255;
    float alpha= [self alpha];
    NSLog(@"\nThis Color's Red:%.0f, Green:%.0f, Blue:%.0f, Alpha:%.0f\ndecimal red:%.4f green:%.4f blue:%.4f \nHexadecimal 0x%x%x%x",R,G,B,alpha,r,g,b,(int)R,(int)G,(int)B);
}


#pragma mark - Other(其它功能)

/**
 *  随机颜色
 *
 *  @return 返回随机颜色
 */
+ (UIColor *)randomColor{
    CGFloat red =  (CGFloat)random()/(CGFloat)RAND_MAX;
    CGFloat blue = (CGFloat)random()/(CGFloat)RAND_MAX;
    CGFloat green = (CGFloat)random()/(CGFloat)RAND_MAX;
    return [UIColor colorWithRed:red green:green blue:blue alpha:1.0];
}


/**
 *  返回十六进制的颜色
 *
 *  @param hex 十六进制
 *
 *  @return 返回十六进制颜色对象
 */
+ (UIColor *)colorWithHex:(UInt32)hex{
    return [self colorWithHex:hex alpha:1.0f];
}

/**
 *  返回十六进制的颜色
 *
 *  @param hex   十六进制
 *  @param alpha 透明度
 *
 *  @return 返回是十六进制的颜色对象
 */
+ (UIColor *)colorWithHex:(UInt32)hex alpha:(CGFloat)alpha{
    int r = (hex >> 16) & 0xFF;
    int g = (hex >> 8) & 0xFF;
    int b = (hex) & 0xFF;
    
    return [UIColor colorWithRed:r / 255.0f
                           green:g / 255.0f
                            blue:b / 255.0f
                           alpha:alpha];
}



/**
 *  十六进制的颜色字符串转换为UIColor
 *
 *  @param color   十六进制的颜色字符串
 *
 *  @return   转换之后的颜色
 */
+ (UIColor *)colorWithHexString:(NSString *)color{
    return [self colorWithHexString:color alpha:1.0f];
}


/**
 *  十六进制的颜色字符串装换为UIColor
 *
 *  @param color 十六进制的颜色字符串
 *  @param alpha 颜色alpha
 *
 *  @return 转换之后的颜色
 */
+ (UIColor *)colorWithHexString:(NSString *)color alpha:(CGFloat)alpha{
    NSString *cString = [[color stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString];
    if ([cString length] < 6) {
        return [UIColor clearColor];
    }
    //截取十六进制前缀
    if ([cString hasPrefix:@"0X"])
        cString = [cString substringFromIndex:2];
    if ([cString hasPrefix:@"#"])
        cString = [cString substringFromIndex:1];
    if ([cString length] != 6)
        return [UIColor clearColor];
    
    //分离RGB三色
    NSRange range;
    range.location = 0;
    range.length = 2;
    
    //r
    NSString *rString = [cString substringWithRange:range];
    
    //g
    range.location = 2;
    NSString *gString = [cString substringWithRange:range];
    
    //b
    range.location = 4;
    NSString *bString = [cString substringWithRange:range];
    
    //扫描颜色值
    unsigned int r, g, b;
    [[NSScanner scannerWithString:rString] scanHexInt:&r];
    [[NSScanner scannerWithString:gString] scanHexInt:&g];
    [[NSScanner scannerWithString:bString] scanHexInt:&b];
    
    return [UIColor colorWithRed:((float) r / 255.0f) green:((float) g / 255.0f) blue:((float) b / 255.0f) alpha:alpha];
}



/**
 *  通过一张图片来创建一个颜色
 *
 *  @param image 图片
 *
 *  @return 返回创建的颜色
 */
+ (UIColor *)colorWithImage:(UIImage *)image{
    return (__bridge UIColor * _Nullable)([UIColor colorWithPatternImage:image].CGColor);
}


#pragma mark - webViewColor
/**
 *  获取canvas用的颜色字符串
 *
 *  @return 返回颜色字符串
 */
- (NSString *)canvasColorString{
    CGFloat *arrRGBA = [self getRGB];
    int r = arrRGBA[0] * 255;
    int g = arrRGBA[1] * 255;
    int b = arrRGBA[2] * 255;
    float a = arrRGBA[3];
    return [NSString stringWithFormat:@"rgba(%d,%d,%d,%f)", r, g, b, a];
}

/**
 *  获取网页颜色字串
 *
 *  @return 返回颜色字符串
 */
- (NSString *) webColorString{
    CGFloat *arrRGBA = [self getRGB];
    int r = arrRGBA[0] * 255;
    int g = arrRGBA[1] * 255;
    int b = arrRGBA[2] * 255;
    NSString *webColor = [NSString stringWithFormat:@"#%02X%02X%02X", r, g, b];
    return webColor;
}

/**
 *  获取RGB值
 *
 *  @return 返回颜色值
 */
- (CGFloat *) getRGB{
    UIColor * uiColor = self;
    
    CGColorRef cgColor = [uiColor CGColor];
    
    size_t numComponents = CGColorGetNumberOfComponents(cgColor);
    
    if (numComponents == 4){
        static CGFloat * components = Nil;
        components = (CGFloat *) CGColorGetComponents(cgColor);
        return (CGFloat *)components;
    } else { //否则默认返回黑色
        static CGFloat components[4] = {0};
        CGFloat f = 0;
        //非RGB空间的系统颜色单独处理
        if ([uiColor isEqual:[UIColor whiteColor]]) {
            f = 1.0;
        } else if ([uiColor isEqual:[UIColor lightGrayColor]]) {
            f = 0.8;
        } else if ([uiColor isEqual:[UIColor grayColor]]) {
            f = 0.5;
        }
        components[0] = f;
        components[1] = f;
        components[2] = f;
        components[3] = 1.0;
        return (CGFloat *)components;
    }
}

/**
 *  让颜色更亮
 *
 *  @return 返回颜色对象
 */
- (UIColor *) lighten{
    CGFloat *rgb = [self getRGB];
    CGFloat r = rgb[0];
    CGFloat g = rgb[1];
    CGFloat b = rgb[2];
    CGFloat alpha = rgb[3];
    
    r = r + (1 - r) / 6.18;
    g = g + (1 - g) / 6.18;
    b = b + (1 - b) / 6.18;
    
    UIColor * uiColor = [UIColor colorWithRed:r green:g blue:b alpha:alpha];
    return uiColor;
}

/**
 *  让颜色更暗
 *
 *  @return 返回颜色对象
 */
- (UIColor *) darken{
    CGFloat *rgb = [self getRGB];
    CGFloat r = rgb[0];
    CGFloat g = rgb[1];
    CGFloat b = rgb[2];
    CGFloat alpha = rgb[3];
    
    r = r * 0.618;
    g = g * 0.618;
    b = b * 0.618;
    
    UIColor *uiColor = [UIColor colorWithRed:r green:g blue:b alpha:alpha];
    return uiColor;
}

/**
 *  取两个颜色的中间
 *
 *  @param color 另外一个颜色
 *
 *  @return 返回中间颜色对象
 */
- (UIColor *) mix: (UIColor *) color{
    CGFloat * rgb1 = [self getRGB];
    CGFloat r1 = rgb1[0];
    CGFloat g1 = rgb1[1];
    CGFloat b1 = rgb1[2];
    CGFloat alpha1 = rgb1[3];
    
    CGFloat * rgb2 = [color getRGB];
    CGFloat r2 = rgb2[0];
    CGFloat g2 = rgb2[1];
    CGFloat b2 = rgb2[2];
    CGFloat alpha2 = rgb2[3];
    
    //mix them!!
    CGFloat r = (r1 + r2) / 2.0;
    CGFloat g = (g1 + g2) / 2.0;
    CGFloat b = (b1 + b2) / 2.0;
    CGFloat alpha = (alpha1 + alpha2) / 2.0;
    
    UIColor * uiColor = [UIColor colorWithRed:r green:g blue:b alpha:alpha];
    return uiColor;
}

@end
